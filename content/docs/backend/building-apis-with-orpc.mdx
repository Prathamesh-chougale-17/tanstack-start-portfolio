---
title: Building APIs with oRPC
description: A complete guide to creating type-safe APIs using oRPC in your projects
---

## What is oRPC?

oRPC (Open RPC) is a type-safe RPC (Remote Procedure Call) framework that allows you to call server functions from the client as if they were local functions, with full TypeScript support and type checking.

## Why Use oRPC?

### Type Safety Across the Full Stack

With oRPC, you get end-to-end type safety. The types defined on the server are automatically available on the client.

### Better Developer Experience

- Autocomplete works across client-server boundary
- Compile-time error checking
- No need for API clients or type generation
- Easy refactoring

### Reduced Boilerplate

No need to create API routes, write schemas, or generate types manually.

## Getting Started

### Server Setup

```tsx
import { oRPC } from '@orpc/server'

const app = oRPC.router({
  user: {
    get: oRPC
      .procedure()
      .input(z.object({ id: z.string() }))
      .output(z.object({ name: z.string(), email: z.string() }))
      .query(async ({ input }) => {
        const user = await getUserById(input.id)
        return user
      }),
    create: oRPC
      .procedure()
      .input(z.object({ name: z.string(), email: z.string() }))
      .mutation(async ({ input }) => {
        const user = await createUser(input)
        return user
      }),
  },
})

export { app }
```

### Client Setup

```tsx
import { createORPCClient } from '@orpc/client'
import { appRouter } from './server'

const client = createORPCClient(appRouter)

// Type-safe calls
const user = await client.user.get({ id: '123' })
const newUser = await client.user.create({
  name: 'John',
  email: 'john@example.com',
})
```

## Advanced Features

### Middleware

```tsx
const app = oRPC.router({
  procedure: oRPC
    .procedure()
    .middleware(async ({ next }) => {
      console.log('Procedure called')
      return next()
    })
    .query(async () => {
      return 'Hello World'
    }),
})
```

### Error Handling

```tsx
try {
  const user = await client.user.get({ id: '123' })
} catch (error) {
  if (error instanceof ORPCErrors) {
    console.error('oRPC error:', error.message)
  }
}
```

## Best Practices

1. **Organize your routers** by feature or domain
2. **Use Zod schemas** for input validation
3. **Implement proper error handling** with meaningful error messages
4. **Add authentication middleware** for protected routes
5. **Use TypeScript strict mode** for maximum type safety

## Conclusion

oRPC provides an excellent developer experience with minimal boilerplate and maximum type safety. It's particularly well-suited for full-stack TypeScript applications.
