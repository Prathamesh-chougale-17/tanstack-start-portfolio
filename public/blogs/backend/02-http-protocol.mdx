---
title: HTTP Protocol
description: Understanding the protocol that powers web communication
---

## What is HTTP?

HTTP (HyperText Transfer Protocol) is the foundation of data communication for the World Wide Web. It defines how messages are formatted and transmitted, and what actions web servers and browsers should take in response to various commands.

## HTTP Request-Response Cycle

```
Client (Browser/App)              Server
       |                             |
       |-- REQUEST ------------------>|
       |  GET /api/users            |
       |  Headers:                 |
       |    Content-Type: application/json
       |    Authorization: Bearer token
       |                             |
       |                             | Process Request
       |                             |
       |<------- RESPONSE ----------|
       |  Status: 200 OK            |
       |  Headers:                 |
       |    Content-Type: application/json
       |  Body: { users: [...] }    |
```

## HTTP Methods

Verbs define the action to be performed on a resource:

### GET

Retrieve data from server

```http
GET /api/users HTTP/1.1
Host: example.com
Accept: application/json
```

### POST

Create new resource

```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}
```

### PUT

Update entire resource

```http
PUT /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John Smith",
  "email": "john.smith@example.com"
}
```

### PATCH

Partially update resource

```http
PATCH /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Jane Doe"
}
```

### DELETE

Remove resource

```http
DELETE /api/users/123 HTTP/1.1
Host: example.com
Authorization: Bearer token123
```

## HTTP Status Codes

### 1xx - Informational

- `100 Continue`: Server received request headers

### 2xx - Success

- `200 OK`: Request succeeded
- `201 Created`: Resource created successfully
- `204 No Content`: Request succeeded but no content returned

### 3xx - Redirection

- `301 Moved Permanently`: Resource moved permanently
- `302 Found`: Resource temporarily moved
- `304 Not Modified`: Resource hasn't changed (cached)

### 4xx - Client Error

- `400 Bad Request`: Invalid request syntax
- `401 Unauthorized`: Authentication required
- `403 Forbidden`: Server refuses to authorize
- `404 Not Found`: Resource doesn't exist
- `409 Conflict`: Request conflicts with current state
- `422 Unprocessable Entity`: Semantic errors in request
- `429 Too Many Requests`: Rate limited

### 5xx - Server Error

- `500 Internal Server Error`: Unexpected server error
- `502 Bad Gateway`: Invalid response from upstream
- `503 Service Unavailable`: Server temporarily unavailable
- `504 Gateway Timeout`: Upstream server timed out

## HTTP Headers

Headers provide additional information about request or response.

### Request Headers

```http
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Accept: application/json
User-Agent: Mozilla/5.0...
Cache-Control: no-cache
```

### Response Headers

```http
Content-Type: application/json; charset=utf-8
Content-Length: 1234
Cache-Control: max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Set-Cookie: session=abc123; HttpOnly; Secure; SameSite=Strict
```

## HTTP Versions

### HTTP/1.0

- Each request requires new connection
- Text-based protocol
- No pipelining

### HTTP/1.1

- Persistent connections (keep-alive)
- Pipelining
- Chunked transfer encoding

### HTTP/2

- Binary protocol
- Multiplexing (multiple requests over single connection)
- Header compression (HPACK)
- Server push

```http
// HTTP/2 connection
Connection: /api/users, /api/posts, /api/comments
Status: All requests sent simultaneously over single TCP connection
```

### HTTP/3 (QUIC)

- UDP-based (not TCP)
- Improved connection migration
- Better error recovery
- Built-in encryption

## HTTPS

HTTPS is HTTP over TLS/SSL encryption.

### Why HTTPS?

1. **Encryption**: Data encrypted in transit
2. **Authentication**: Verifies server identity
3. **Integrity**: Prevents tampering

### TLS Handshake

```
Client                          Server
   |                               |
   |-- Client Hello (supported ciphers) ->|
   |                               |
   |<-- Server Hello (chosen cipher) ----|
   |<-- Certificate (server identity) ----|
   |                               |
   |-- Verify Certificate ------------->|
   |-- Key Exchange -------------->|
   |                               |
   |<-- Finished (encrypted) ----------|
   |-- Finished (encrypted) -------->|
   |                               |
   |<-- Encrypted Communication ----|
```

## HTTP in Modern Backend Development

### Using HTTP in Node.js (Hono)

```tsx
import { Hono } from 'hono'

const app = new Hono()

app.get('/api/users', (c) => {
  // Get request headers
  const userAgent = c.req.header('User-Agent')
  const accept = c.req.header('Accept')

  // Set response headers
  c.header('Cache-Control', 'max-age=3600')
  c.header('X-Custom-Header', 'value')

  // Return response with status
  return c.json(
    { users: [...] },
    200 // Optional, defaults to 200
  )
})

// Handle different methods
app.post('/api/users', async (c) => {
  const body = await c.req.json()
  const created = await createUser(body)

  return c.json(created, 201)
})
```

### Using HTTP in Express.js

```tsx
import express from 'express'

const app = express()

app.get('/api/users', (req, res) => {
  // Access headers
  const userAgent = req.get('User-Agent')

  // Set headers
  res.set('Cache-Control', 'max-age=3600')

  // Send response
  res.status(200).json({ users: [...] })
})

app.post('/api/users', (req, res) => {
  const body = req.body

  // Create user
  const user = await createUser(body)

  // Return 201 for created resource
  res.status(201).json(user)
})
```

## Best Practices

### 1. Use Correct Status Codes

```tsx
// Bad
if (!user) {
  return c.json({ error: 'Not found' }, 200)
}

// Good
if (!user) {
  return c.json({ error: 'Not found' }, 404)
}
```

### 2. Use Appropriate Methods

```tsx
// Bad: Use GET for mutations
app.get('/api/users/:id/delete', deleteUser)

// Good: Use DELETE
app.delete('/api/users/:id', deleteUser)
```

### 3. Set Proper Headers

```tsx
// Security headers
c.header('X-Content-Type-Options', 'nosniff')
c.header('X-Frame-Options', 'DENY')
c.header('X-XSS-Protection', '1; mode=block')
c.header('Strict-Transport-Security', 'max-age=31536000')

// CORS headers (if needed)
c.header('Access-Control-Allow-Origin', 'https://example.com')
c.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE')
c.header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
```

### 4. Implement Caching

```tsx
app.get('/api/public-data', (c) => {
  const data = await getCachedData()

  c.header('Cache-Control', 'public, max-age=3600')
  c.header('ETag', generateETag(data))

  if (c.req.header('If-None-Match') === getETag(data)) {
    return c.body(null, 304) // Not modified
  }

  return c.json(data)
})
```

## Common HTTP Issues

### 1. Request Entity Too Large (413)

**Problem**: Client sending too much data

**Solution**: Increase limit or use streaming

```tsx
app.use(express.json({ limit: '10mb' }))
```

### 2. Timeout (408/504)

**Problem**: Request or processing taking too long

**Solution**: Implement timeout handling

```tsx
const timeout = setTimeout(() => {
  return c.json({ error: 'Timeout' }, 504)
}, 30000)
```

### 3. CORS Errors

**Problem**: Browser blocking cross-origin requests

**Solution**: Configure CORS properly

```tsx
import { cors } from 'hono/cors'

app.use(
  '/*',
  cors({
    origin: ['https://example.com'],
    allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowHeaders: ['Content-Type', 'Authorization'],
  }),
)
```

## Conclusion

HTTP is fundamental to web development. Understanding HTTP methods, status codes, headers, and protocols is essential for building robust backend APIs. Modern HTTP/2 and HTTP/3 offer significant performance improvements over HTTP/1.1.

Always use proper HTTP semantics, status codes, and security headers to build professional, production-ready APIs.

**Next:** [Routing](/blogs/backend/03-routing) - How backend systems route requests to correct handlers.
